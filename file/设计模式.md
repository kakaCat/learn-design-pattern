#设计模式的六大原则
>总原则－开闭原则
>>对扩展开放，对修改封闭。在程序需要进行拓展的时候，<font color=red  face=“黑体”>不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。</font>所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。
想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。
>>
>
>1、单一职责原则
>>不要存在多于一个导致类变更的原因，<font color=red  face=“黑体”>也就是说每个类应该实现单一的职责，</font>否则就应该把类拆分。
>>
>
>2、里氏替换原则（Liskov Substitution Principle）
>>任何基类可以出现的地方，子类一定可以出现。里氏替换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。
里氏代换原则是对“开-闭”原则的补充。实现“开闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。里氏替换原则中，<font color=red  face=“黑体”>子类对父类的方法尽量不要重写和重载。</font>因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。
>>
>
>3、依赖倒转原则（Dependence Inversion Principle）
>>面向接口编程，<font color=red  face=“黑体”>依赖于抽象而不依赖于具体。</font>写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。
>>
>
>4、接口隔离原则（Interface Segregation Principle）
>>每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。<font color=red  face=“黑体”>接口在子类中用不到，需要拆分出来</font>
>>
>
>5、合成复用原则（Composite Reuse Principle）
>>尽量首先使用合成/聚合的方式，<font color=red  face=“黑体”>而不是使用继承。</font>
>>
>
5、迪米特法则（最少知道原则）（Demeter Principle） 
>>不要存在多于一个导致类变更的原因，<font color=red  face=“黑体”>也就是说每个类应该实现单一的职责，</font>否则就应该把类拆分。
>>
>



#装饰器模式(Decorator,Wrapper)



#适配器模式


|     装饰器模式     |    适配器模式    |
|:---------:|:----------:| 
|         电动  |     左对齐    |
|=========|===============|


#观察者模式
##发送者(Observer) 和 接受者(Subject)
>事件(Event)
>>事件源(source) 不需要暴露
>>通知目标(target) 不需要暴漏
>>回调(callback)
>>触发(trgger)
> 
>事件绑定(EventLisenter)
>>events(hashmap 容器)
>>addLisenter(添加事件)
>>trigger()
>>trigger(触发)



#总结
##创建型
>spring->BeanFactory FactoryBean

##单例模式:为了提高资源重复利用 通过技术手段保证在整个系统运行阶段 只有一个实例
##场景 配置文件 监控程序 ico容器 日历
>spring中最常见的 注册登记式 效率性能最高的内部类

##原型模式 复制
##spring重点 对象原型 主要是为里 配置信息能够被重复使用,而且互不干扰



##代理模式
##应用场景 中介 黄牛 经纪人
##代码场景 字节码增强 动态实现非侵入式编程
##完成一件事 代理只参与摸一部分的功能
##技术手段 jdk proxy cglib aspectj asm

##策略模式 将一些固定的算法统一起来
##应用场景 旅游路线的选择 出行方式的选择 饮料制作原料选择
##特点 巧妙的避免 if-else 或者 swith

##模版方法 流程固定 某一个环节有差异
##应用场景 jdbcTemplate 工作流

##委派模式 代理模式的特殊情况 全权代理
##应用场景 项目经理 Dispatcher
##代码场景 Spring中的SevlertDispatcher

##适配器模式 兼容 转换
##应用场景 
##代码场景 登录 为了 兼容旧的代码

##装饰器模式 委派+适配器 注重扩展 覆盖 is-a的关系
##应用场景 io留 数据源
##Spring中 Derocator warper

##观察者模式 针对于目标对象的一举一动 要的得到反馈
##应用场景 事件监听 日志监听 短信通知 
